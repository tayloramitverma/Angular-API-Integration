{"version":3,"file":"ngx-infinite-scroll.umd.min.js","sources":["../../src/services/ngx-ins-utils.ts","../../src/services/event-trigger.ts","../../src/services/position-resolver.ts","../../src/services/scroll-resolver.ts","../../src/services/scroll-register.ts","../../src/services/axis-resolver.ts","../../src/services/scroll-state.ts","../../src/modules/infinite-scroll.directive.ts","../../src/modules/ngx-infinite-scroll.module.ts"],"sourcesContent":["import { ElementRef, SimpleChange } from '@angular/core';\n\nexport function resolveContainerElement(\n  selector: string | any,\n  scrollWindow,\n  defaultElement,\n  fromRoot: boolean\n): any {\n  const hasWindow = window && !!window.document && window.document.documentElement;\n  let container = hasWindow && scrollWindow ? window : defaultElement;\n  if (selector) {\n    const containerIsString =\n      selector && hasWindow && typeof selector === 'string';\n    container = containerIsString\n      ? findElement(selector, defaultElement.nativeElement, fromRoot)\n      : selector;\n    if (!container) {\n      throw new Error('ngx-infinite-scroll {resolveContainerElement()}: selector for');\n    }\n  }\n  return container;\n}\n\nexport function findElement(\n  selector: string | any,\n  customRoot: ElementRef | any,\n  fromRoot: boolean\n) {\n  const rootEl = fromRoot ? window.document : customRoot;\n  return rootEl.querySelector(selector);\n}\n\nexport function inputPropChanged(prop: SimpleChange): boolean {\n  return prop && !prop.firstChange;\n}\n\nexport function hasWindowDefined(): boolean {\n  return typeof window !== 'undefined';\n}\n","import { InfiniteScrollEvent, IPositionStats } from '../models';\n\nexport interface IScrollerProps extends IDistanceRange {\n  container: IPositionStats;\n  alwaysCallback: boolean;\n  disabled: boolean;\n}\n\nexport interface ITriggerEvents {\n  down: (event: any) => any;\n  up: (event: any) => any;\n}\n\nexport interface IDistanceRange {\n  down: number;\n  up: number;\n}\n\nexport interface IScrollConfig {\n  alwaysCallback: boolean;\n  shouldFireScrollEvent: boolean;\n}\n\nexport function shouldTriggerEvents(\n  alwaysCallback: boolean,\n  shouldFireScrollEvent: boolean,\n  isTriggeredCurrentTotal: boolean\n) {\n  if (alwaysCallback && shouldFireScrollEvent) {\n    return true;\n  }\n  if (!isTriggeredCurrentTotal && shouldFireScrollEvent) {\n    return true;\n  }\n  return false;\n}\n","import { ElementRef } from '@angular/core';\n\nimport { ContainerRef, IPositionElements, IPositionStats, IResolver } from '../models';\nimport { AxisResolver } from './axis-resolver';\n\nexport function createResolver({\n  windowElement,\n  axis\n}: IPositionElements): IResolver {\n  return createResolverWithContainer(\n    { axis, isWindow: isElementWindow(windowElement) },\n    windowElement\n  );\n}\n\nexport function createResolverWithContainer(\n  resolver,\n  windowElement: ContainerRef\n) {\n  const container =\n    resolver.isWindow || (windowElement && !windowElement.nativeElement)\n      ? windowElement\n      : windowElement.nativeElement;\n  return { ...resolver, container };\n}\n\nexport function isElementWindow(windowElement: ContainerRef): boolean {\n  const isWindow = ['Window', 'global'].some((obj: string) =>\n    Object.prototype.toString.call(windowElement).includes(obj)\n  );\n  return isWindow;\n}\n\nexport function getDocumentElement(isContainerWindow: boolean, windowElement) {\n  return isContainerWindow ? windowElement.document.documentElement : null;\n}\n\nexport function calculatePoints(element: ElementRef, resolver: IResolver) {\n  const height = extractHeightForElement(resolver);\n  return resolver.isWindow\n    ? calculatePointsForWindow(height, element, resolver)\n    : calculatePointsForElement(height, element, resolver);\n}\n\nexport function calculatePointsForWindow(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container, isWindow } = resolver;\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  // scrolled until now / current y point\n  const scrolled =\n    height +\n    getElementPageYOffset(\n      getDocumentElement(isWindow, container),\n      axis,\n      isWindow\n    );\n  // total height / most bottom y point\n  const nativeElementHeight = getElementHeight(\n    element.nativeElement,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n  const totalToScroll =\n    getElementOffsetTop(element.nativeElement, axis, isWindow) +\n    nativeElementHeight;\n  return { height, scrolled, totalToScroll };\n}\n\nexport function calculatePointsForElement(\n  height: number,\n  element: ElementRef,\n  resolver: IResolver\n): IPositionStats {\n  const { axis, container } = resolver;\n  // perhaps use container.offsetTop instead of 'scrollTop'\n  const scrolled = container[axis.scrollTopKey()];\n  const totalToScroll = container[axis.scrollHeightKey()];\n  return { height, scrolled, totalToScroll };\n}\n\nexport function extractHeightPropKeys(axis: AxisResolver) {\n  return {\n    offsetHeightKey: axis.offsetHeightKey(),\n    clientHeightKey: axis.clientHeightKey()\n  };\n}\n\nexport function extractHeightForElement({\n  container,\n  isWindow,\n  axis\n}: IResolver) {\n  const { offsetHeightKey, clientHeightKey } = extractHeightPropKeys(axis);\n  return getElementHeight(\n    container,\n    isWindow,\n    offsetHeightKey,\n    clientHeightKey\n  );\n}\nexport function getElementHeight(\n  elem: any,\n  isWindow: boolean,\n  offsetHeightKey: string,\n  clientHeightKey: string\n) {\n  if (isNaN(elem[offsetHeightKey])) {\n    const docElem = getDocumentElement(isWindow, elem);\n    return docElem ? docElem[clientHeightKey] : 0;\n  } else {\n    return elem[offsetHeightKey];\n  }\n}\n\nexport function getElementOffsetTop(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const topKey = axis.topKey();\n  // elem = elem.nativeElement;\n  if (!elem.getBoundingClientRect) {\n    // || elem.css('none')) {\n    return;\n  }\n  return (\n    elem.getBoundingClientRect()[topKey] +\n    getElementPageYOffset(elem, axis, isWindow)\n  );\n}\n\nexport function getElementPageYOffset(\n  elem: ContainerRef,\n  axis: AxisResolver,\n  isWindow: boolean\n) {\n  const pageYOffset = axis.pageYOffsetKey();\n  const scrollTop = axis.scrollTopKey();\n  const offsetTop = axis.offsetTopKey();\n\n  if (isNaN(window[pageYOffset])) {\n    return getDocumentElement(isWindow, elem)[scrollTop];\n  } else if (elem.ownerDocument) {\n    return elem.ownerDocument.defaultView[pageYOffset];\n  } else {\n    return elem[offsetTop];\n  }\n}\n","import { IPositionStats, IScrollState, IScrollerDistance } from '../models';\n\nexport function shouldFireScrollEvent(\n  container: IPositionStats,\n  distance: IScrollerDistance,\n  scrollingDown: boolean\n) {\n  let remaining: number;\n  let containerBreakpoint: number;\n  if (container.totalToScroll <= 0) {\n    return false;\n  }\n  const scrolledUntilNow = container.height + container.scrolled;\n  if (scrollingDown) {\n    remaining =\n      (container.totalToScroll - scrolledUntilNow) / container.totalToScroll;\n    containerBreakpoint = distance.down / 10;\n  } else {\n    const totalHiddenContentHeight =\n      container.scrolled + (container.totalToScroll - scrolledUntilNow);\n    remaining = container.scrolled / totalHiddenContentHeight;\n    containerBreakpoint = distance.up / 10;\n  }\n\n  const shouldFireEvent: boolean = remaining <= containerBreakpoint;\n  return shouldFireEvent;\n}\n\nexport function isScrollingDownwards(\n  lastScrollPosition: number,\n  container: IPositionStats\n) {\n  return lastScrollPosition < container.scrolled;\n}\n\nexport function getScrollStats(\n  lastScrollPosition: number,\n  container: IPositionStats,\n  distance: IScrollerDistance\n) {\n  const scrollDown = isScrollingDownwards(lastScrollPosition, container);\n  return {\n    fire: shouldFireScrollEvent(container, distance, scrollDown),\n    scrollDown\n  };\n}\n\nexport function updateScrollPosition(\n  position: number,\n  scrollState: IScrollState\n) {\n  return (scrollState.lastScrollPosition = position);\n}\n\nexport function updateTotalToScroll(\n  totalToScroll: number,\n  scrollState: IScrollState\n) {\n  if (scrollState.lastTotalToScroll !== totalToScroll) {\n    scrollState.lastTotalToScroll = scrollState.totalToScroll;\n    scrollState.totalToScroll = totalToScroll;\n  }\n}\n\nexport function isSameTotalToScroll(scrollState: IScrollState) {\n  return scrollState.totalToScroll === scrollState.lastTotalToScroll;\n}\n\nexport function updateTriggeredFlag(\n  scroll,\n  scrollState: IScrollState,\n  triggered: boolean,\n  isScrollingDown: boolean\n) {\n  if (isScrollingDown) {\n    scrollState.triggered.down = scroll;\n  } else {\n    scrollState.triggered.up = scroll;\n  }\n}\n\nexport function isTriggeredScroll(\n  totalToScroll,\n  scrollState: IScrollState,\n  isScrollingDown: boolean\n) {\n  return isScrollingDown\n    ? scrollState.triggered.down === totalToScroll\n    : scrollState.triggered.up === totalToScroll;\n}\n\nexport function updateScrollState(\n  scrollState: IScrollState,\n  scrolledUntilNow: number,\n  totalToScroll: number\n) {\n  updateScrollPosition(scrolledUntilNow, scrollState);\n  updateTotalToScroll(totalToScroll, scrollState);\n  // const isSameTotal = isSameTotalToScroll(scrollState);\n  // if (!isSameTotal) {\n  //   updateTriggeredFlag(scrollState, false, isScrollingDown);\n  // }\n}\n","import { Observable, of, fromEvent } from 'rxjs';\nimport { map, mergeMap, tap, sampleTime, filter } from 'rxjs/operators';\n\nimport * as Models from '../models';\nimport { AxisResolver } from './axis-resolver';\nimport { shouldTriggerEvents } from './event-trigger';\nimport { resolveContainerElement } from './ngx-ins-utils';\nimport { calculatePoints, createResolver } from './position-resolver';\nimport * as ScrollResolver from './scroll-resolver';\nimport { ScrollState } from './scroll-state';\n\nexport function createScroller(config: Models.IScroller) {\n  const { scrollContainer, scrollWindow, element, fromRoot } = config;\n  const resolver = createResolver({\n    axis: new AxisResolver(!config.horizontal),\n    windowElement: resolveContainerElement(\n      scrollContainer,\n      scrollWindow,\n      element,\n      fromRoot\n    )\n  });\n  const scrollState = new ScrollState({\n    totalToScroll: calculatePoints(element, resolver)\n  });\n  const options: Models.IScrollRegisterConfig = {\n    container: resolver.container,\n    throttle: config.throttle\n  };\n  const distance = {\n    up: config.upDistance,\n    down: config.downDistance\n  };\n  return attachScrollEvent(options).pipe(\n    mergeMap(() => of(calculatePoints(element, resolver))),\n    map((positionStats: Models.IPositionStats) =>\n      toInfiniteScrollParams(\n        scrollState.lastScrollPosition,\n        positionStats,\n        distance\n      )\n    ),\n    tap(({ stats }: Models.IScrollParams) =>\n      scrollState.updateScroll(stats.scrolled, stats.totalToScroll)\n    ),\n    filter(\n      ({ fire, scrollDown, stats: { totalToScroll } }: Models.IScrollParams) =>\n        shouldTriggerEvents(\n          config.alwaysCallback,\n          fire,\n          scrollState.isTriggeredScroll(totalToScroll, scrollDown)\n        )\n    ),\n    tap(({ scrollDown, stats: { totalToScroll } }: Models.IScrollParams) => {\n      scrollState.updateTriggeredFlag(totalToScroll, scrollDown);\n    }),\n    map(toInfiniteScrollAction)\n  );\n}\n\nexport function attachScrollEvent(\n  options: Models.IScrollRegisterConfig\n): Observable<{}> {\n  let obs = fromEvent(options.container, 'scroll');\n  // For an unknown reason calling `sampleTime()` causes trouble for many users, even with `options.throttle = 0`.\n  // Let's avoid calling the function unless needed.\n  // See https://github.com/orizens/ngx-infinite-scroll/issues/198\n  if (options.throttle) {\n    obs = obs.pipe(sampleTime(options.throttle));\n  }\n  return obs;\n}\n\nexport function toInfiniteScrollParams(\n  lastScrollPosition: number,\n  stats: Models.IPositionStats,\n  distance: Models.IScrollerDistance\n): Models.IScrollParams {\n  const { scrollDown, fire } = ScrollResolver.getScrollStats(\n    lastScrollPosition,\n    stats,\n    distance\n  );\n  return {\n    scrollDown,\n    fire,\n    stats\n  };\n}\n\nexport const InfiniteScrollActions = {\n  DOWN: '[NGX_ISE] DOWN',\n  UP: '[NGX_ISE] UP'\n};\n\nexport function toInfiniteScrollAction(\n  response: Models.IScrollParams\n): Models.IInfiniteScrollAction {\n  const {\n    scrollDown,\n    stats: { scrolled: currentScrollPosition }\n  } = response;\n  return {\n    type: scrollDown ? InfiniteScrollActions.DOWN : InfiniteScrollActions.UP,\n    payload: {\n      currentScrollPosition\n    }\n  };\n}\n","const VerticalProps = {\n  clientHeight: \"clientHeight\",\n  offsetHeight: \"offsetHeight\",\n  scrollHeight: \"scrollHeight\",\n  pageYOffset: \"pageYOffset\",\n  offsetTop: \"offsetTop\",\n  scrollTop: \"scrollTop\",\n  top: \"top\"\n};\n\nconst HorizontalProps = {\n  clientHeight: \"clientWidth\",\n  offsetHeight: \"offsetWidth\",\n  scrollHeight: \"scrollWidth\",\n  pageYOffset: \"pageXOffset\",\n  offsetTop: \"offsetLeft\",\n  scrollTop: \"scrollLeft\",\n  top: \"left\"\n};\n\nexport class AxisResolver {\n  private propsMap: any;\n\n  constructor(private vertical: boolean = true) {\n    this.propsMap = vertical ? VerticalProps : HorizontalProps;\n  }\n  clientHeightKey() {\n    return this.propsMap.clientHeight;\n  }\n  offsetHeightKey() {\n    return this.propsMap.offsetHeight;\n  }\n  scrollHeightKey() {\n    return this.propsMap.scrollHeight;\n  }\n  pageYOffsetKey() {\n    return this.propsMap.pageYOffset;\n  }\n  offsetTopKey() {\n    return this.propsMap.offsetTop;\n  }\n  scrollTopKey() {\n    return this.propsMap.scrollTop;\n  }\n  topKey() {\n    return this.propsMap.top;\n  }\n}\n","import { IScrollState, IScrollerDistance } from '../models';\n\nexport class ScrollState implements IScrollState {\n  lastScrollPosition = 0;\n  lastTotalToScroll = 0;\n  totalToScroll = 0;\n  triggered: IScrollerDistance = {\n    down: 0,\n    up: 0\n  };\n\n  constructor({ totalToScroll }) {\n    this.totalToScroll = totalToScroll;\n  }\n\n  updateScrollPosition(position: number) {\n    return (this.lastScrollPosition = position);\n  }\n\n  updateTotalToScroll(totalToScroll: number) {\n    if (this.lastTotalToScroll !== totalToScroll) {\n      this.lastTotalToScroll = this.totalToScroll;\n      this.totalToScroll = totalToScroll;\n    }\n  }\n\n  updateScroll(scrolledUntilNow: number, totalToScroll: number) {\n    this.updateScrollPosition(scrolledUntilNow);\n    this.updateTotalToScroll(totalToScroll);\n  }\n\n  updateTriggeredFlag(scroll, isScrollingDown: boolean) {\n    if (isScrollingDown) {\n      this.triggered.down = scroll;\n    } else {\n      this.triggered.up = scroll;\n    }\n  }\n\n  isTriggeredScroll(totalToScroll, isScrollingDown: boolean) {\n    return isScrollingDown\n      ? this.triggered.down === totalToScroll\n      : this.triggered.up === totalToScroll;\n  }\n}\n","import {\n  AfterViewInit,\n  Directive,\n  ElementRef,\n  EventEmitter,\n  Input,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  Output,\n  SimpleChanges\n} from '@angular/core';\nimport {Subscription} from 'rxjs';\n\nimport { InfiniteScrollEvent, IInfiniteScrollAction } from '../models';\nimport { hasWindowDefined, inputPropChanged } from '../services/ngx-ins-utils';\nimport { createScroller, InfiniteScrollActions } from '../services/scroll-register';\n\n@Directive({\n  selector: '[infiniteScroll], [infinite-scroll], [data-infinite-scroll]'\n})\nexport class InfiniteScrollDirective\n  implements OnDestroy, OnChanges, AfterViewInit {\n  @Output() scrolled = new EventEmitter<InfiniteScrollEvent>();\n  @Output() scrolledUp = new EventEmitter<InfiniteScrollEvent>();\n\n  @Input() infiniteScrollDistance: number = 2;\n  @Input() infiniteScrollUpDistance: number = 1.5;\n  @Input() infiniteScrollThrottle: number = 150;\n  @Input() infiniteScrollDisabled: boolean = false;\n  @Input() infiniteScrollContainer: any = null;\n  @Input() scrollWindow: boolean = true;\n  @Input() immediateCheck: boolean = false;\n  @Input() horizontal: boolean = false;\n  @Input() alwaysCallback: boolean = false;\n  @Input() fromRoot: boolean = false;\n\n  private disposeScroller: Subscription;\n\n  constructor(private element: ElementRef, private zone: NgZone) { }\n\n  ngAfterViewInit() {\n    if (!this.infiniteScrollDisabled) {\n      this.setup();\n    }\n  }\n\n  ngOnChanges({ infiniteScrollContainer, infiniteScrollDisabled, infiniteScrollDistance }: SimpleChanges) {\n    const containerChanged = inputPropChanged(infiniteScrollContainer);\n    const disabledChanged = inputPropChanged(infiniteScrollDisabled);\n    const distanceChanged = inputPropChanged(infiniteScrollDistance);\n    const shouldSetup = (!disabledChanged && !this.infiniteScrollDisabled) ||\n      (disabledChanged && !infiniteScrollDisabled.currentValue) || distanceChanged;\n\n    if (containerChanged || disabledChanged || distanceChanged) {\n      this.destroyScroller();\n      if (shouldSetup) {\n        this.setup();\n      }\n    }\n  }\n\n  setup() {\n    if (hasWindowDefined()) {\n      this.zone.runOutsideAngular(() => {\n        this.disposeScroller = createScroller({\n          fromRoot: this.fromRoot,\n          alwaysCallback: this.alwaysCallback,\n          disable: this.infiniteScrollDisabled,\n          downDistance: this.infiniteScrollDistance,\n          element: this.element,\n          horizontal: this.horizontal,\n          scrollContainer: this.infiniteScrollContainer,\n          scrollWindow: this.scrollWindow,\n          throttle: this.infiniteScrollThrottle,\n          upDistance: this.infiniteScrollUpDistance\n        }).subscribe((payload: any) => this.zone.run(() => this.handleOnScroll(payload)));\n      });\n    }\n  }\n\n  handleOnScroll({ type, payload }: IInfiniteScrollAction) {\n    switch (type) {\n      case InfiniteScrollActions.DOWN:\n        return this.scrolled.emit(payload);\n\n      case InfiniteScrollActions.UP:\n        return this.scrolledUp.emit(payload);\n\n      default:\n        return;\n    }\n  }\n\n  ngOnDestroy() {\n    this.destroyScroller();\n  }\n\n  destroyScroller() {\n    if (this.disposeScroller) {\n      this.disposeScroller.unsubscribe();\n    }\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { InfiniteScrollDirective } from './infinite-scroll.directive';\n\n@NgModule({\n  declarations: [InfiniteScrollDirective],\n  exports: [InfiniteScrollDirective],\n  imports: [],\n  providers: []\n})\nexport class InfiniteScrollModule { }\n"],"names":["resolveContainerElement","selector","scrollWindow","defaultElement","fromRoot","hasWindow","window","document","documentElement","container","findElement","nativeElement","Error","customRoot","querySelector","inputPropChanged","prop","firstChange","hasWindowDefined","shouldTriggerEvents","alwaysCallback","shouldFireScrollEvent","isTriggeredCurrentTotal","createResolver","_a","windowElement","createResolverWithContainer","axis","isWindow","isElementWindow","resolver","Object","assign","some","obj","prototype","toString","call","includes","getDocumentElement","isContainerWindow","calculatePoints","element","height","extractHeightForElement","calculatePointsForWindow","calculatePointsForElement","extractHeightPropKeys","offsetHeightKey","clientHeightKey","scrolled","getElementPageYOffset","nativeElementHeight","getElementHeight","totalToScroll","getElementOffsetTop","scrollTopKey","scrollHeightKey","_b","elem","isNaN","docElem","topKey","getBoundingClientRect","pageYOffset","pageYOffsetKey","scrollTop","offsetTop","offsetTopKey","ownerDocument","defaultView","distance","scrollingDown","remaining","containerBreakpoint","scrolledUntilNow","down","totalHiddenContentHeight","up","isScrollingDownwards","lastScrollPosition","getScrollStats","scrollDown","fire","createScroller","config","scrollContainer","AxisResolver","horizontal","scrollState","ScrollState","options","throttle","upDistance","downDistance","attachScrollEvent","pipe","mergeMap","of","map","positionStats","toInfiniteScrollParams","tap","stats","updateScroll","filter","isTriggeredScroll","updateTriggeredFlag","toInfiniteScrollAction","obs","fromEvent","sampleTime","response","currentScrollPosition","type","InfiniteScrollActions","DOWN","UP","payload","VerticalProps","clientHeight","offsetHeight","scrollHeight","top","HorizontalProps","vertical","this","propsMap","lastTotalToScroll","triggered","updateScrollPosition","position","updateTotalToScroll","scroll","isScrollingDown","InfiniteScrollDirective","zone","EventEmitter","scrolledUp","infiniteScrollDistance","infiniteScrollUpDistance","infiniteScrollThrottle","infiniteScrollDisabled","infiniteScrollContainer","immediateCheck","ngAfterViewInit","setup","ngOnChanges","containerChanged","disabledChanged","distanceChanged","shouldSetup","currentValue","destroyScroller","_this","runOutsideAngular","disposeScroller","disable","subscribe","run","handleOnScroll","emit","ngOnDestroy","unsubscribe","Directive","args","ElementRef","NgZone","Output","Input","InfiniteScrollModule","NgModule","declarations","exports","imports","providers"],"mappings":"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"}